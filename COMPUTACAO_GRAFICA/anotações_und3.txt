
static Vertex vec_sub(Vertex a, Vertex b) {
    return (Vertex) {
        a.x - b.x,
        a.y - b.y,
        a.z - b.z
    };
}

static Vertex vec_cross(Vertex a, Vertex b) {
    return (Vertex) {
        a.y * b.z - a.z * b.y,
        a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x
    };
} // Produto escalar

static float vec_dot(Vertex a, Vertex b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
} // Produto vetorial

static Vertex vec_scalar( float s, Vertex a) {
    return (Vertex) {
        a.x * s,
        a.y * s,
        a.z * s
    }; // Produto escalar
}
static Vertex vec_normalize(Vertex v) {
    float length = sqrtf(v.x * v.x + v.y * v.y + v.z * v.z);
    if(length == 0.0f) {
        return (Vertex) {0, 0, 0}; // Retorna vetor nulo se o comprimento for zero
    }
    return (Vertex) {v.x / length,
                     v.y / length,
                     v.z / length};
} // Normalização do vetor

void barycentric_coordinate( Vertex a, Vertex b, Vertex c, float red, float green, float blue ){

   // calculando o bounding box
    int x_min = floorf(fminf(fminf(a.x, b.x), c.x));
    int x_max = ceilf(fmaxf(fmaxf(a.x, b.x), c.x));
    int y_min = floorf(fminf(fminf(a.y, b.y), c.y));
    int y_max = ceilf(fmaxf(fmaxf(a.y, b.y), c.y));

    // Encontrando a área do triangulo abc
    float area_abc = 0.5 * fabsf(a.x*(b.y - c.y) + b.x*(c.y - a.y) + c.x*(a.y - b.y));

    for (int y = y_min; y < y_max; y++){
        for (int x = x_min; x < x_max; x++){
            Vertex p = {x, y, 0};
            // Encontrando a área dos triangulos
            float area_pbc = 0.5 * (p.x*(b.y - c.y) + b.x*(c.y - p.y) + c.x*(p.y - b.y));
            float area_apc = 0.5 * (a.x*(p.y - c.y) + p.x*(c.y - a.y) + c.x*(a.y - p.y));
            float area_abp = 0.5 * (a.x*(b.y - p.y) + b.x*(p.y - a.y) + p.x*(a.y - b.y));
            float alfa = area_pbc / area_abc;
            float beta = area_apc / area_abc;
            float gamma = area_abp / area_abc;
            if ( alfa >= 0.0 && beta >= 0.0 && gamma >= 0.0 ){
                set_pixel( x, y, red, green, blue );
            }
        }
    }

}

float iluminacao( Vertex v0, Vertex v1, Vertex v2, Vertex L, Vertex V, float ka, float kd, float ks, int n ){  

Vertex ab = vec_sub(v1, v0);
Vertex ac = vec_sub(v2, v0);
Vertex N = vec_normalize(vec_cross(ab, ac));

Vertex L_n = vec_normalize(L);
Vertex V_n = vec_normalize(V);

float diffuse = fmaxf(0.0f, vec_dot(N, L_n));
Vertex R = vec_sub( vec_scalar(2.0 * vec_dot(N, L_n),N), L_n);
float spec = powf(fmaxf(0.0f, vec_dot(R, V_n)), n);

float intensity = ka + kd * diffuse + ks * spec;
if (intensity > 1.0f) {
    intensity = 1.0f;
}

return intensity;

}

//Esferaaa

Vertex add( Vertex a, Vertex b ){ return (Vertex){a.x + b.x, a.y + b.y, a.z + b.z}; }
Vertex sub( Vertex a, Vertex b ){ return (Vertex){a.x - b.x, a.y - b.y, a.z - b.z}; }
Vertex scale( Vertex v, float s ){ return (Vertex){s*v.x, s*v.y, s*v.z}; }
float dot(Vertex a, Vertex b){ return a.x*b.x + a.y*b.y + a.z*b.z; }
float length(Vertex v){ return sqrtf(dot(v, v)); }
Vertex normalize( Vertex v ){ return scale(v, 1.0f / length(v)); }

void save(){
    printf("P3\n %d %d\n 255\n", WIDTH, HEIGHT);
    for (int y = 0; y < HEIGHT; y++){
        for (int x = 0; x < WIDTH; x++){
            for (int c = 0; c < 3; c++){
                printf("%d \t", img[x][y][c]);
            }
            printf("\n");
        }
    }
}

// Retorna t (distância) ou -1 se não há interseção
float intersecao_esfera( Vertex O, Vertex D, Vertex C, float r ){
    Vertex L = sub( O, C );
    float a = dot( D, D );
    float b = 2.0 * dot(L, D);
    float c = dot(L, L) - r * r;
    float delta = b * b - 4 * a * c;
    if ( delta < 0 ) return -1.0;
    float sqrt_delta = sqrtf( delta );
    float t0 = (-b - sqrt_delta) / (2 * a);
    float t1 = (-b + sqrt_delta) / (2 * a);
    if ( t0 > 0.001 ) return t0;
    if ( t1 > 0.001 ) return t1;
    return -1.0;
}

// Retorna t (distância) ou -1 se não há interseção
float intersecao_plano(Vertex O, Vertex D, Vertex P, Vertex N){
    float denominador = dot( N, D );
    
    if ( fabsf(denominador) < 0.0 ) return -1.0;
    
    float t = dot( sub(P, O), N ) / denominador;

    return ( t > 0.0 ) ? t : -1.0;
}
